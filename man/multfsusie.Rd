% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multfsusie.R
\name{multfsusie}
\alias{multfsusie}
\title{Sum of multiple Single Functions}
\usage{
multfsusie(
  Y,
  X,
  L = 2,
  pos = NULL,
  prior = "mixture_normal",
  post_processing = "TI",
  verbose = TRUE,
  maxit = 100,
  tol = 0.001,
  cov_lev = 0.95,
  min.purity = 0.5,
  L_start = 3,
  filter.cs = TRUE,
  init_pi0_w = 1,
  nullweight = 10,
  control_mixsqp = list(eps = 1e-06, numiter.em = 40, verbose = FALSE),
  thresh_lowcount,
  cal_obj = FALSE,
  greedy = TRUE,
  backfit = TRUE,
  max_SNP_EM = 1000,
  gridmult = sqrt(2),
  max_scale = 10,
  max_step_EM = 1,
  cor_small = FALSE,
  filter.number = 10,
  family = "DaubLeAsymm",
  e = 0.001
)
}
\arguments{
\item{Y}{a list of   data frames
in which element from univariate traits are stored in Y$Y_u, one column corresponds to a univariate trait
 (can be set to NULL if no univariate traits considered) and functional traits are stored in the sub list Y$Y_f
 where each element of the sub list  Y$Y_f is a n by T data frame (T being the number of observation points)
 (can be NULL if no functional trait considered)}

\item{X}{matrix of size n by p contains the covariates}

\item{L}{the number of effect to fit (if not specified set to =2)
#'@param  post_processing character, use "TI" for translation invariant wavelet estimates,
"HMM" for hidden Markov model (useful for estimating non-zero regions),
"none" for simple wavelet estimate (not recommended)}

\item{pos}{vector of length J, corresponding to position/time pf
the observed column in each entery of Y$Y_f, if missing suppose that the observation
are evenly spaced}

\item{prior}{specify the prior used in functional trait. The two available choices are
available "mixture_normal_per_scale", "mixture_normal". Default "mixture_normal",
 using  "mixture_normal" is up to 40% faster but may lead to slight power loss}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress,
and a summary of the optimization settings, are printed to the
console.}

\item{maxit}{Maximum number of IBSS iterations to perform.}

\item{tol}{A small, non-negative number specifying the convergence
tolerance for the IBSS fitting procedure. The fitting procedure
will halt when the difference in the variational lower bound, or
\dQuote{ELBO} (the objective function to be maximized), is less
than \code{tol}.}

\item{cov_lev}{numeric between 0 and 1, corresponding to the
expected level of coverage of the cs if not specified set to 0.95}

\item{min.purity}{minimum purity for estimated credible sets}

\item{L_start}{number of effect initialized at the start of the algorithm}

\item{filter.cs}{logical, if TRUE filter the credible set (removing low purity cs and cs with estimated prior equal to 0)}

\item{init_pi0_w}{starting value of weight on null compoenent in mixsqp
(between 0 and 1)}

\item{nullweight}{numeric value for penalizing likelihood at point mass 0 (should be between 0 and 1)
(usefull in small sample size)}

\item{control_mixsqp}{list of parameter for mixsqp function see  mixsqp package}

\item{thresh_lowcount}{list  of numeric (check example), use to check the
 wavelet coefficients/univariate trait have with
problematic distribution (very low dispersion even after standardization).
Basically check if the median of the absolute value of the distribution of
 a wavelet coefficient/univariate trait is below a given threshold, if yes the algorithm discard
 this wavelet coefficient (setting its estimate effect to 0 and estimate sd to 1).
 Set to 0 by default. Can be useful when analyzing sparse data from sequence
  based assay or small samples.}

\item{cal_obj}{logical if set as true compute ELBO for convergence monitoring}

\item{greedy}{logical, if true allow greedy search for extra effect
(up to L specify by the user). Set as TRUE by default}

\item{backfit}{logical, if true allow discarding effect via backfitting.
Set as true by default as TRUE. We advise to keep it as TRUE}

\item{e}{threshold value to avoid computing posterior that have low alpha value. Set it to 0 to compute the entire posterior. default value is 0.001}
}
\description{
Implementation of the multfSuSiE method
}
\details{
Implementation of the multfSuSiE method
}
\examples{
library(mvf.susie.alpha)
set.seed(1)

N <- 100 # Sample size
P <- 100 # Number of SNPs
L <- 2 # Number of effects
list_lev_res <- list(5, 6) # Two functional phenotypes, one of length 2^5 and one of length 2^6
n_univ <- 3 # 3 univariate phenotypes
eff <- list()
for (l in 1:L) { # Simulate the multi-trait effect
  eff[[l]] <- simu_effect_multfsusie(list_lev_res=list_lev_res, n_univ=n_univ, output_level=2)
}

Y_f1 <- matrix(rnorm((2^list_lev_res[[1]]) * N, sd=1), nrow=N)
Y_f2 <- matrix(rnorm((2^list_lev_res[[2]]) * N, sd=1), nrow=N)
Y_u <- matrix(rnorm(n_univ * N, sd=1), nrow=N)

G <- matrix(sample(c(0, 1, 2), size=N*P, replace=TRUE), nrow=N, ncol=P) # Genotype matrix
true_pos <- sample(1:ncol(G), L) # Actually causal columns/SNPs

for (i in 1:N) {
  for (l in 1:L) {
    Y_f1[i,] <- Y_f1[i,] + eff[[l]]$func_effect[[1]]$sim_func * G[i, true_pos[[l]]]
    Y_f2[i,] <- Y_f2[i,] + eff[[l]]$func_effect[[2]]$sim_func * G[i, true_pos[[l]]]
    Y_u[i,] <- Y_u[i,] + eff[[l]]$univ_effect * G[i, true_pos[[l]]]
  }
}

Y_f <- list(Y_f1, Y_f2)
Y <- list(Y_f=Y_f, Y_u=Y_u) # Preparing data

pos <- list(pos1=1:ncol(Y$Y_f[[1]]), pos2=1:ncol(Y$Y_f[[2]])) # If your signal is sampled between 1 and 64

m1 <- multfsusie(Y=Y, X=G, pos=pos, L=3)
print(m1$cs) # Credible sets
print(true_pos)

par(mfrow=c(2,1))
plot(m1$fitted_func[[1]][[1]], type="l", col="green", main="Estimated function for the first marker", ylab="y")
lines(eff[[2]]$func_effect[[1]]$sim_func)
lines(m1$cred_band[[1]][[1]][1,], lty=2, col="darkgreen")
lines(m1$cred_band[[1]][[1]][2,], lty=2, col="darkgreen")

plot(m1$fitted_func[[1]][[2]], type="l", col="green", main="Estimated function for the second marker", ylab="y")
lines(eff[[2]]$func_effect[[2]]$sim_func)
lines(m1$cred_band[[1]][[2]][1,], lty=2, col="darkgreen")
lines(m1$cred_band[[1]][[2]][2,], lty=2, col="darkgreen")

#a bit slower but usefull for properly estimating the support of the effectr
m1 <- multfsusie(Y=Y,
                X=G,
                pos=pos,
                L=3 ,
                post_processing = "HMM")


plot( m1$fitted_func[[1]][[1]], type="l", col="green", main="estimated function for the first mark",ylab="y" )
lines( eff[[2]]$func_effect[[1]]$sim_func)
abline(h=0)
lines( m1$lfsr[[1]]$est_lfsr_functional[[1]], lty=2, col="darkgreen"  )
plot( m1$fitted_func[[1]][[2]], type="l", col="green", main="estimated function for the first mark",ylab="y" )
lines( eff[[2]]$func_effect[[2]]$sim_func)
abline(h=0)
lines( m1$lfsr[[1]]$est_lfsr_functional[[2]], lty=2, col="darkgreen"  )

}
