% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multfsusie.R
\name{multfsusie}
\alias{multfsusie}
\title{Sum of multiple Single Functions}
\usage{
multfsusie(
  Y,
  X,
  L = 2,
  pos = NULL,
  data.format = "list_df",
  verbose = TRUE,
  maxit = 100,
  tol = 0.001,
  cov_lev = 0.95,
  min.purity = 0.5,
  L_start = 3,
  filter.cs = TRUE,
  init_pi0_w = 1,
  nullweight,
  control_mixsqp = list(eps = 1e-06, numiter.em = 40, verbose = FALSE),
  thresh_lowcount,
  cal_obj = FALSE,
  greedy = TRUE,
  backfit = TRUE
)
}
\arguments{
\item{Y}{list of observed time series. Length of N in which every element
contains a xi (number of condition) by 2^S matrix. The matrix corresponds to the
individuals multivariate time series}

\item{X}{matrix of size n by p contains the covariates}

\item{L}{the number of effect to fit (if not specified set to =2)}

\item{pos}{vector of length J, corresponding to position/time pf
the observed column in Y, if missing suppose that the observation
are evenly spaced}

\item{data.format}{character specify hw the input data is organised,
"ind_mark" the input is a list in which each element is a list of individual mark measurement.
 "list_df", corresponds to the case where the input is a list of  of data frames
  in which element from univariate trait are stored in Y$Y_u, one column corresponds to a univariate trait
   (can be set to NULL if no univariate trait considered) and functional trait are stored in the sub list Y$Y_f
   where each element of the sub list  Y$Y_f is a n by T data frame (T being the number of observation points)
   (can be NULL if no functional trait considered)}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress,
and a summary of the optimization settings, are printed to the
console.}

\item{maxit}{Maximum number of IBSS iterations to perform.}

\item{tol}{A small, non-negative number specifying the convergence
tolerance for the IBSS fitting procedure. The fitting procedure
will halt when the difference in the variational lower bound, or
\dQuote{ELBO} (the objective function to be maximized), is less
than \code{tol}.}

\item{cov_lev}{numeric between 0 and 1, corresponding to the
expected level of coverage of the cs if not specified set to 0.95}

\item{min.purity}{minimum purity for estimated credible sets}

\item{L_start}{number of effect initialized at the start of the algorithm}

\item{filter.cs}{logical, if TRUE filter the credible set (removing low purity cs and cs with estimated prior equal to 0)
@param thresh_lowcount list  of numeric (check example), use to check the
 wavelet coefficients/univariate trait have with
problematic distribution (very low dispersion even after standardization).
Basically check if the median of the absolute value of the distribution of
 a wavelet coefficient/univariate trait is below a given threshold, if yes the algorithm discard
 this wavelet coefficient (setting its estimate effect to 0 and estimate sd to 1).
 Set to 0 by default. Can be useful when analyzing sparse data from sequence
  based assay or small samples.}

\item{init_pi0_w}{starting value of weight on null compoenent in mixsqp
(between 0 and 1)}

\item{nullweight}{numeric value for penalizing likelihood at point mass 0 (should be between 0 and 1)
(usefull in small sample size)}

\item{control_mixsqp}{list of parameter for mixsqp function see  mixsqp package}

\item{thresh_lowcount}{numeric, use to check the wavelet coefficients have
problematic distribution (very low dispersion even after standardization).
Basically check if the median of the absolute value of the distribution of
 a wavelet coefficient is below this threshold, if yes the algorithm discard
 this wavelet coefficient (setting its estimate effect to 0 and estimate sd to 1).
 Set to 0 by default. Can be useful when analyzing sparse data from sequence
  based assay or small samples.}

\item{cal_obj}{logical if set as true compute ELBO for convergence monitoring}

\item{greedy}{logical, if true allow greedy search for extra effect
(up to L specify by the user). Set as TRUE by default}

\item{backfit}{logical, if true allow discarding effect via backfitting.
Set as true by default as TRUE. We advise to keep it as TRUE}
}
\description{
Implementation of the multfSuSiE method
}
\details{
Implementation of the multfSuSiE method
}
\examples{


library(mvf.susie.alpha)
set.seed(1)

N <- 100 #Sample size
P= 100 # number of SNP
L <- sample(1:10, size=1) #Number of effect
print(L)
list_lev_res <- list(5,6) # two functional phenotypes ,
#one of length 2^5, and one of length 2^6)
n_univ <- 3 #3 univariate phenotypes
eff <-  list()
for(l in 1:L){ #Simulate the mult-trait effect
 eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
                                       n_univ=n_univ, output_level = 2)
}


Y_f1 <-  matrix(rnorm((2^list_lev_res[[1]])*N ,sd=1), nrow = N)
Y_f2 <-  matrix(rnorm((2^list_lev_res[[2]])*N ,sd=1), nrow = N)

Y_u <- matrix(rnorm((n_univ)*N ,sd=1), nrow = N)


G = matrix(sample(c(0, 1,2), size=N*P, replace=TRUE), nrow=N, ncol=P) #Genotype


true_pos <- sample( 1:ncol(G), L)# actually causal column/SNP

for ( i in 1:N){
 for ( l in 1:L){

   Y_f1[i,]<- Y_f1[i,]+eff[[l]]$func_effect[[1]]$sim_func*G[i,true_pos[[l]]]
   Y_f2[i,]<- Y_f2[i,]+eff[[l]]$func_effect[[2]]$sim_func*G[i,true_pos[[l]]]
   Y_u[i,]<- Y_u[i,]+ eff[[l]]$univ_effect*G[i,true_pos[[l]]]
 }
}

Y_f <- list()
Y_f[[1]] <- Y_f1
Y_f[[2]] <- Y_f2
Y <- list( Y_f = Y_f, Y_u=Y_u) # preparing data ,
#current ouput type expect list of two which element named
#Y_f for functional trait and Y_u for univariate trait

m1 <- multfsusie(Y=Y,
                X=G,
                L=11 ,
                data.format="list_df",
                L_start=11 ,
                nullweight=10,
                maxit=10)
m1$cs# credible sets


##thresholding some trait

#create object for trhesholding some trait for a user specified value thresholding

threshs <- threshold_set_up( thresh_u= rep(1e-3,3), thresh_f = c(1e-3, 1e-3))

m1 <- multfsusie(Y=Y,
                X=G,
                L=11 ,
                data.format="list_df",
                L_start=11,
                thresh_lowcount=threshs,
                maxit=10)
}
