test_that("check greedy backfit",{
iter=1
init=TRUE
for( l in 1:multfsusie.obj$L)
{
update_Y <- cal_partial_resid(multfsusie.obj = multfsusie.obj,
l              = (l-1)  ,
X              = X,
Y              = Y_data,
list_indx_lst  = list_indx_lst
)
if(verbose){
print(paste("Fitting effect ", l,", iter" ,  iter ))
}
if(init){#recycle operation used to fit the prior
EM_out <- susiF.alpha:::gen_EM_out (tpi_k= get_pi_G_prior(G_prior),
lBF  = log_BF(G_prior,
effect_estimate,
list_indx_lst,
low_trait = low_trait)
)
class(EM_out) <- c("EM_pi_multfsusie","list")
init <- FALSE
}else{
effect_estimate   <- cal_Bhat_Shat_multfsusie(update_Y,X,v1,
low_trait      = low_trait,
ind_analysis   = ind_analysis,
parallel       = parallel
)
tpi               <- get_pi(multfsusie.obj,1)
G_prior           <- update_prior(G_prior, tpi= tpi) #allow EM to start close to previous solution (to double check)
EM_out  <- EM_pi_multsusie(G_prior         = G_prior,
effect_estimate = effect_estimate,
list_indx_lst   = list_indx_lst,
init_pi0_w      = init_pi0_w,
control_mixsqp  = control_mixsqp,
nullweight      = nullweight,
low_trait       = low_trait,
df              = df
)
}
multfsusie.obj <- update_multfsusie(multfsusie.obj  = multfsusie.obj ,###TODO:: SLOW
l               = l,
EM_pi           = EM_out,
effect_estimate = effect_estimate,
list_indx_lst   = list_indx_lst,
low_trait       = low_trait )
}#end for l in 1:L  -----
multfsusie.obj$lfsr_wc
multfsusie.obj$lfsr_u
multfsusie.obj <- greedy_backfit (multfsusie.obj,
verbose        = verbose,
cov_lev        = cov_lev,
X              = X,
min.purity     = min.purity
)
iter =  iter+1
expect_equal(multfsusie.obj$L ,  (7+3))
expect_equal(length(multfsusie.obj$fitted_wc),  (7+3))
expect_equal(length(multfsusie.obj$fitted_u),  (7+3))
expect_equal( multfsusie.obj$cs[[1]], 1)
expect_equal( multfsusie.obj$cs[[2]], 5)
expect_equal( multfsusie.obj$cs[[3]], 10)
for( l in 1:multfsusie.obj$L)
{
update_Y <- cal_partial_resid(multfsusie.obj = multfsusie.obj,
l              = (l-1)  ,
X              = X,
Y              = Y_data,
list_indx_lst  = list_indx_lst
)
if(verbose){
print(paste("Fitting effect ", l,", iter" ,  iter ))
}
if(init){#recycle operation used to fit the prior
EM_out <- susiF.alpha:::gen_EM_out (tpi_k= get_pi_G_prior(G_prior),
lBF  = log_BF(G_prior,
effect_estimate,
list_indx_lst,
low_trait = low_trait)
)
class(EM_out) <- c("EM_pi_multfsusie","list")
init <- FALSE
}else{
effect_estimate   <- cal_Bhat_Shat_multfsusie(update_Y,X,v1,
low_trait      = low_trait,
ind_analysis   = ind_analysis,
parallel       = parallel
)
tpi               <- get_pi(multfsusie.obj,1)
G_prior           <- update_prior(G_prior, tpi= tpi) #allow EM to start close to previous solution (to double check)
EM_out  <- EM_pi_multsusie(G_prior         = G_prior,
effect_estimate = effect_estimate,
list_indx_lst   = list_indx_lst,
init_pi0_w      = init_pi0_w,
control_mixsqp  = control_mixsqp,
nullweight      = nullweight,
low_trait       = low_trait,
df              = df
)
}
multfsusie.obj <- update_multfsusie(multfsusie.obj  = multfsusie.obj ,###TODO:: SLOW
l               = l,
EM_pi           = EM_out,
effect_estimate = effect_estimate,
list_indx_lst   = list_indx_lst,
low_trait       = low_trait )
}#end for l in 1:L  -----
multfsusie.obj$lfsr_wc
multfsusie.obj$lfsr_u
multfsusie.obj <- greedy_backfit (multfsusie.obj,
verbose        = verbose,
cov_lev        = cov_lev,
X              = X,
min.purity     = min.purity
)
multfsusie.obj$cs
})
##### la -----
test_that("The performance  of multfsusie on  this example should be",{
library(susiF.alpha)
library(mvf.susie.alpha)
set.seed(1)
N=100
P=50
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta1       <- 1
beta2       <- 1
L <- 4#actual number of effect
lf <-  list()
for(l in 1:L){
lf[[l]] <- simu_IBSS_per_level(lev_res=5)$sim_func #functional effect for effect l
}
tt <- sample(0:4,1)
if( length(which(apply(G,2,var)==0))>0){
G <- G[,-which(apply(G,2,var)==0)]
}
# G <- matrix( rnorm(100*300), nrow = 100)
true_pos <- sample( 1:ncol(G), L)
Y <- matrix(rnorm((2^5)*100 ,sd=4), nrow = 100)
for ( i in 1:100){
for ( l in 1:L){
Y[i,] <- Y[i,]+ lf[[l]]*G[i,true_pos[[l]]]
}
}
Y_f <- list()
Y_f[[1]] <- Y
Y <- list( Y_f = Y_f, Y_u=NULL)
m1 <- multfsusie(Y=Y,
X=G,
L=11 ,
L_start=11 ,
nullweight=10,
cal_obj =FALSE,
maxit=10, verbose=FALSE)
expect_lt(  sqrt(mean( (m1$fitted_func[[2]][[1]]-lf[[3]])^2)),0.7)
expect_lt(  sqrt(mean( (m1$fitted_func[[1]][[1]]-lf[[1]])^2)),0.7)
expect_lt(  sqrt(mean( (m1$fitted_func[[3]][[1]]-lf[[2]])^2)),0.7)
expect_equal( length(which(true_pos%in% do.call(c, m1$cs))) , length(true_pos))
}
)
##### lfsr -----
G_prior <- get_G_prior(multfsusie.obj)
cal_clfsr(G_prior         = get_G_prior(multfsusie.obj),
effect_estimate = effect_estimate,
list_indx_lst   = list_indx_lst)
stats::complete.cases
stats::median
simple_sims
fsusieR::simple_sims
#'@title Simulate effect under the multfsusie model
#'@description Simulate effect under the multfsusie model
#'@param list_lev_res list of level of resolution (can be set to NULL if non)
#'@param n_univ number of univariate trait to be analysed
#'@param effect_univ possible effect size of the SNP on the univariate phenotype (if missing the effect size are sample at random as -1 or 1)
#'@param output_level if equal to 1 (default) provide simplified output for functional effect, setting it to 2 provide more detailled output see
#'simu_IBSS_per_level in fsusieR for additional details
#'@export
#'@examples
#'
#'
#'list_lev_res <- list(5,7)
#'n_univ <- 4
#'effect <-  simu_effect_multfsusie (list_lev_res=list_lev_res,n_univ=n_univ)
#'
simu_effect_multfsusie <- function(list_lev_res=NULL, n_univ=NULL, effect_univ,
output_level=1){
if (output_level %!in% c(1,2))
{
stop("output_level should be between 1 and 2")
}
if(missing(effect_univ)){
effect_univ <- c( -1,1)
}
if( output_level==1){
if (!is.null(list_lev_res)){
func_effect <- list()
for ( k in 1:length(list_lev_res)){
func_effect[[k]] <- fsusieR::simu_IBSS_per_level  ( lev_res=list_lev_res[[k]])$sim_func
}
}
}
if(output_level==2){
if (!is.null(list_lev_res)){
func_effect <- list()
for ( k in 1:length(list_lev_res)){
func_effect[[k]] <- fsusieR::simu_IBSS_per_level  ( lev_res=list_lev_res[[k]])
}
}
}
if(!is.null(n_univ)){
univ_effect <- sample(effect_univ, size=n_univ, replace=TRUE)
}
out <- list(func_effect =func_effect,
univ_effect = univ_effect)
return( out)
}
#'@title Simulate function under the mash per scale prior
#'@description Simulate function under the mash per scale prior
#'@param lev_res numerical corresponds to the resolution of the simulated function (idealy between 3 and 10)
#'@param n_curve  dimension of the multivaraite time serie to generate
#'@param length_grid vector numerical corresponds to the length of the grid of sigma for mixture component(cf ash)
#'@param pi0 vector numerical , contain a digit  between 0 and 1, which corresponds to the null proportion ( non assocatied wavelet coefficients)
#'@param alpha numeric >0, control smoothness of the curves, should be positive and up 4 in particular d_sl ~  pi_{0,sl}  delta_0 + sum_k  pi_k N(0, 2^{- alpha * s}   sigma_k^2)
#'@param prop_decay numeric >0, control the proportion of non zero wavelet coefficient per scale, pi_{0,sl} = 1- exp(-prop_decay*s)
#'@param is.plot logical, if true plot the simualted effect
#' @export
#to do : add decay per scale to get same level of smoothing
mvf_susie_per_level  <-function( lev_res=7,
n_curve=3,
length_grid= 10,
pi0, #point less for the moment
alpha=0.8,
prop_decay=0.1,
is.plot=TRUE)
{
if(missing(pi0))
{
pi0 <- 1-exp(- (  prop_decay*(1:lev_res)))
}
#usefull to parse the indexes of wavelt coefficients
indx_lst <- list()
indx_lst[[1]] <- 1 #coefficient
for ( s in 1:(lev_res-1))
{
indx  <- (2^s):(2^((s+1))-1)
indx_lst[[s+1]] <- indx
}
#for the sake of ease same grid for each scale
G_level <-list()
tem_func <- matrix(0,ncol= n_curve, nrow= 2^lev_res)
twav <- wd(tem_func[,1])
tem_wt_func <- matrix( twav$D , length(twav$D) , n_curve )
G_level <-list() #list of the mixture per scale
for ( i in 1:lev_res)
{
simdata = simple_sims(50,3,1)
data = mashr::mash_set_data(simdata$Bhat, simdata$Shat)
U.c = cov_canonical(data)
m = mash(data, U.c, algorithm.version = 'R', posterior_samples = 100)
G_level[[i]] <- m
for ( k in unlist(indx_lst[i]))
{
# clust <- sample (1:length_grid, prob=G_level[[i]]$pi, size=1)
tem_wt_func[k,] <-   simdata$Bhat[k,]
#print(twav$D[k])
}
}
#writing the the final function
sim_func <-  tem_func
for( j in 1:n_curve)
{
twav$D <-  tem_wt_func[,j]
sim_func[,j] <- wr(twav)
}
#plot(accessD(twav,level=6), rev( tt$D[unlist(indx_lst[7])]) )
if(is.plot)
{
plot( sim_func[,1], type="l", ylim = c(min(sim_func),max(sim_func)))
for( i in 1:n_curve)
{
lines(sim_func[,i], col=i)
}
}
out <- list( sim_func  = sim_func,
true_coef =tem_wt_func,
mix_per_scale=G_level
#emp_pi0=emp_pi0
)
return(out)
}
mvf_susie_per_level
mvf_susie_per_level()
library(wavethresh)
mvf_susie_per_level()
mashr::cov_canonical
lines
? lines
tail
?tail
library(mvf.susie.alpha)
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
## ----setup--------------------------------------------------------------------
library(mvf.susie.alpha)
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 5,
fig.height = 3,
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 175
)
par(mar = c(1, 1, 1, 1))
library(mvf.susie.alpha)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 120
)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(fsusieR)
library(mvf.susie.alpha)
library(ashr)
library(susieR)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)
rsnr <- 0.5 #expected root signal noise ratio
pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res1 <- 5#length of the functional phenotype 1 phenotype (2^lev_res)
lev_res2 <- 6#length of the molecular phenotype (2^lev_res)
L <-  2
list_lev_res <- list(lev_res1,lev_res2)
n_univ <- 3
eff <-  list()
for(l in 1:L){
eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
}
simu_effect_multfsusie
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(fsusieR)
library(mvf.susie.alpha)
library(ashr)
library(susieR)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)
rsnr <- 0.5 #expected root signal noise ratio
pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res1 <- 5#length of the functional phenotype 1 phenotype (2^lev_res)
lev_res2 <- 6#length of the molecular phenotype (2^lev_res)
L <-  2
list_lev_res <- list(lev_res1,lev_res2)
n_univ <- 3
eff <-  list()
for(l in 1:L){
eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
}
simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
devtools::load_all(".")
simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
library(mvf.susie.alpha)
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
## ----setup--------------------------------------------------------------------
library(mvf.susie.alpha)
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 5,
fig.height = 3,
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 175
)
par(mar = c(1, 1, 1, 1))
library(mvf.susie.alpha)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 120
)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(fsusieR)
library(mvf.susie.alpha)
library(ashr)
library(susieR)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)
rsnr <- 0.5 #expected root signal noise ratio
pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res1 <- 5#length of the functional phenotype 1 phenotype (2^lev_res)
lev_res2 <- 6#length of the molecular phenotype (2^lev_res)
L <-  2
list_lev_res <- list(lev_res1,lev_res2)
n_univ <- 3
eff <-  list()
for(l in 1:L){
eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
}
library(mvf.susie.alpha)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(fsusieR)
library(mvf.susie.alpha)
library(ashr)
library(susieR)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)
rsnr <- 0.5 #expected root signal noise ratio
pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res1 <- 5#length of the functional phenotype 1 phenotype (2^lev_res)
lev_res2 <- 6#length of the molecular phenotype (2^lev_res)
L <-  2
list_lev_res <- list(lev_res1,lev_res2)
n_univ <- 3
eff <-  list()
for(l in 1:L){
eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
}
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
## ----setup--------------------------------------------------------------------
library(mvf.susie.alpha)
## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 5,
fig.height = 3,
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 175
)
par(mar = c(1, 1, 1, 1))
library(mvf.susie.alpha)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.align = "center",
fig.cap = "&nbsp;",
dpi = 120
)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(fsusieR)
library(mvf.susie.alpha)
library(ashr)
library(susieR)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)
rsnr <- 0.5 #expected root signal noise ratio
pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res1 <- 5#length of the functional phenotype 1 phenotype (2^lev_res)
lev_res2 <- 6#length of the molecular phenotype (2^lev_res)
L <-  2
list_lev_res <- list(lev_res1,lev_res2)
n_univ <- 3
eff <-  list()
for(l in 1:L){
eff[[l]] <-   simu_effect_multfsusie (list_lev_res=list_lev_res,
n_univ=n_univ, output_level = 2)
}
