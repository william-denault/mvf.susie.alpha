
# @title Initialize the prior for multfsusie method
#
# @description generate list of object corresponding to the parameters of the prior for analysis
#
# @param Y a list of functional phenotype, in which each element is matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#
# @param X matrix of size n by p in
#
# @param list_indx_lst list of list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#
# @return an object of the class "mult_prior"
#
# @importFrom ashr ash
#
# @export
init_prior_multfsusie <- function(Y,X, v1 ,
                                  list_indx_lst=NULL,
                                  low_trait=NULL,
                                  control_mixsqp,
                                  nullweight,ind_analysis,
                                  parallel=FALSE,
                                  max_SNP_EM,
                                  gridmult=sqrt(2),
                                  max_step_EM=100
                                  )
{

  if(is.null(Y$Y_u)){
    G_prior_u <- NULL
    res_uni   <- NULL
  }else{
    if(missing(ind_analysis )){
      res_uni   <- susiF.alpha:::cal_Bhat_Shat(Y$Y_u,X,v1)
    }else{
      res_uni   <- susiF.alpha:::cal_Bhat_Shat(Y$Y_u,X,v1,lowc_wc=NULL,ind_analysis =ind_analysis$idx_u)
    }

    if (is.null(low_trait$low_u)){
              G_prior_u <- lapply(1:ncol(Y$Y_u), function(j) ashr::ash(res_uni$Bhat[,j],
                                                                  res_uni$Shat[,j] ,
                                                                  mixcompdist = "normal" ,
                                                                  outputlevel=0,
                                                                  gridmult=gridmult)
                              )
    }else{
      G_prior_u <- lapply((1:ncol(Y$Y_u))[- low_trait$low_u], function(j) ashr::ash(res_uni$Bhat[,j],
                                                                          res_uni$Shat[,j],
                                                                          mixcompdist = "normal" ,
                                                                          outputlevel=0,
                                                                          gridmult=gridmult)
                              )
      }

    #### TODO add optimization step here to bypass for effect fitting
    for ( k in 1: length(G_prior_u)){
      attr(G_prior_u[[k]], "class")  <- "mixture_normal"
    }

  }

  if(is.null(Y$Y_f)){
    G_prior_f < NULL
    res_f <- NULL
  }else{
    if(missing(ind_analysis)){

      if( parallel){
        t_G_prior_f <-parallel::mclapply(1:length(Y$Y_f),
                             function(k) susiF.alpha:::init_prior.default( Y              = Y$Y_f[[k]],
                                                                           X              = X,
                                                                           v1             = v1,
                                                                           prior          = "mixture_normal_per_scale",
                                                                           indx_lst       = list_indx_lst[[k]],
                                                                           lowc_wc        = low_trait$low_wc[[k]],
                                                                           control_mixsqp = control_mixsqp,
                                                                           nullweight     =  nullweight,
                                                                           max_SNP_EM     = max_SNP_EM,
                                                                           gridmult       = gridmult,
                                                                           max_step_EM    = max_step_EM
                                                                           #TODO make it different depending on marks
                                                                           ),
                                       mc.cores=numCores,
                                       mc.preschedule=FALSE
                                      )
      }else{
        t_G_prior_f <-lapply(1:length(Y$Y_f),
                             function(k) susiF.alpha:::init_prior.default( Y              = Y$Y_f[[k]],
                                                                           X              = X,
                                                                           v1             = v1,
                                                                           prior          = "mixture_normal_per_scale",
                                                                           indx_lst       = list_indx_lst[[k]],
                                                                           lowc_wc        = low_trait$low_wc[[k]],
                                                                           control_mixsqp = control_mixsqp,
                                                                           nullweight     =  nullweight,
                                                                           max_SNP_EM     = max_SNP_EM,
                                                                           gridmult       = gridmult,
                                                                           max_step_EM    = max_step_EM
                                                                           #TODO make it different depending on marks
                             )
        )
      }

    }else{
      if(parallel){
        t_G_prior_f <-parallel::mclapply(1:length(Y$Y_f),
                             function(k) susiF.alpha:::init_prior.default( Y              = Y$Y_f[[k]],
                                                                           X              = X,
                                                                           v1             = v1,
                                                                           prior          = "mixture_normal_per_scale",
                                                                           indx_lst       = list_indx_lst[[k]],
                                                                           lowc_wc        = low_trait$low_wc[[k]],
                                                                           control_mixsqp =control_mixsqp,
                                                                           nullweight     = nullweight,
                                                                           ind_analysis   = ind_analysis$idx_f[[k]],
                                                                           max_SNP_EM     = max_SNP_EM,
                                                                           gridmult       = gridmult,
                                                                           max_step_EM    = max_step_EM
                                                                           #TODO make it different depending on marks
                             ),
                             mc.cores=numCores,
                             mc.preschedule=FALSE
        )

      }else{
        t_G_prior_f <-lapply(1:length(Y$Y_f),
                             function(k) susiF.alpha:::init_prior.default( Y              = Y$Y_f[[k]],
                                                                           X              = X,
                                                                           v1             = v1,
                                                                           prior          = "mixture_normal_per_scale",
                                                                           indx_lst       = list_indx_lst[[k]],
                                                                           lowc_wc        = low_trait$low_wc[[k]],
                                                                           control_mixsqp = control_mixsqp,
                                                                           nullweight     = nullweight,
                                                                           ind_analysis   = ind_analysis$idx_f[[k]],
                                                                           max_SNP_EM     = max_SNP_EM,
                                                                           gridmult       = gridmult,
                                                                           max_step_EM    = max_step_EM
                                                                           #TODO make it different depending on marks
                             )
        )
      }

    }

    G_prior_f <- lapply(1:length(Y$Y_f), function(k)  t_G_prior_f [[k]]$G_prior)
    res_f     <- lapply(1:length(Y$Y_f), function(k)  t_G_prior_f [[k]]$tt)
  }


  res  <- list( res_uni = res_uni,
                res_f   = res_f)
  G_prior <- list( G_prior_u = G_prior_u,
                   G_prior_f = G_prior_f)

    attr(G_prior, "class") <- "multfsusie_prior"



  return(list(G_prior=G_prior,
              res= res)
  )

}


#' @export
#' @keywords internal

get_pi_G_prior <- function(G_prior, ...)
  UseMethod("get_pi_G_prior")


#' @title Extract mixture component from a multfsusie_prior
#
#' @param G_prior an object of class "multfsusie_prior"
#' @return an object of class "pi_multfsusie" which is a list of two
#\item {est_pi_u} corresponding of the k ash prior for each of the univariate traits
#\item {est_pi_f} corresponding of the k  "mixture_normal_per_scale" prior for each of the functional trait
#' @export
#' @keywords internal

get_pi_G_prior.multfsusie_prior <- function(G_prior)
{

  if(is.null(G_prior$G_prior_u))
  {
    est_pi_u <- NULL
  }else{
    est_pi_u <- lapply(G_prior$G_prior_u, function(x) x$fitted_g$pi)
  }

  if( is.null(G_prior$G_prior_f))
  {
    est_pi_f <- NULL
  }else{
    est_pi_f <- lapply(1:length(G_prior$G_prior_f),
                       function(j)
                         susiF.alpha::get_pi_G_prior(G_prior$G_prior_f[[j]])
                       )
  }

  out <- list(est_pi_u= est_pi_u,
              est_pi_f = est_pi_f
              )
  attr(out, "class") <- "pi_multfsusie"
  return( out)
}


# @title update_prior univariate prior k
#
# @param k integer component to be updated
# @param tpi  an object of class pi_multfsusie
# @param G_prior a prior of class multfsusie_prior
#
# @export
#
update_G_prior_univ_mult <- function(k,  tpi, G_prior)
{

  G_prior$G_prior_u[[k]]$fitted_g$pi <- tpi$est_pi_u[[k]]
  return(G_prior$G_prior_u[[k]])
}


#' @title Update prior for multfsusie object
#' @description see title
#' @param G_prior a prior for multfsusie object
#' @param tpi mixture proportions
#' @export
#' @keywords internal

update_prior <- function(G_prior, tpi, ...)
  UseMethod("update_prior")

#' @rdname update_prior
#
#' @method update_prior multfsusie_prior
#
#' @export update_prior.multfsusie_prior
#
#' @export
#' @keywords internal



update_prior.multfsusie_prior <- function(G_prior, tpi, ... ){

  if( !(inherits(tpi,"pi_multfsusie")))
  {
    stop("tpi should be of class pi_multfsusie")
  }
  if (!is.null(G_prior$G_prior_u)){
    G_prior$G_prior_u<- lapply( 1:length(G_prior$G_prior_u), function(k) update_G_prior_univ_mult(k , tpi,G_prior)
                                )
  }



  if (!is.null(G_prior$G_prior_f)){

    G_prior$G_prior_f <- lapply( 1:length(G_prior$G_prior_f), function(k) susiF.alpha::update_prior(
                                                                                 G_prior$G_prior_f[[k]],
                                                                                 tpi$est_pi_f[[k]])
    )


  }
  return(G_prior)

}
