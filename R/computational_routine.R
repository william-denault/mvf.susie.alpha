

# @title Regress different marks of Y   on X nxp
#
# @description regression coefficients (and sd) of the column wise regression
#
# @param Y a list of two, Y_u containning a N by J data frame of univariate phneotype and Y_f a k list contains a list of functionnal phenoytpes
#
# @param X matrix of size N by P in
#
# @return a nested list list of two
#
# \item{res_u}{ list of two Bhat: matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of the t univariate phneotype
#  on X[,j]; Shat is the matrix of the corresponding standard error }
#
# \item{res_f}{ a list of k in which each element contains Bhat and Shat matrix (see description in item res_u}
#
# @export


cal_Bhat_Shat_multfsusie <- function( Y,X,v1,
                                      list_indx_lst=NULL,
                                      low_trait=NULL,
                                      ind_analysis   )
{

  if(is.null(Y$Y_u)){
    res_u <- NULL
  }else{
    if(missing(ind_analysis)){
      res_u   <- fsusieR:::cal_Bhat_Shat(Y=Y$Y_u,
                                               X=X,
                                               v1=v1,
                                               lowc_wc=low_trait$low_u)
    #  res_u$Shat <- res_u$Shat%*%diag(sqrt(multfsusie.obj$sigma2$sd_u))
    }else{
      res_u   <- fsusieR:::cal_Bhat_Shat(Y=Y$Y_u,
                                               X=X,
                                               v1=v1,
                                               lowc_wc=low_trait$low_u,
                                               ind_analysis=ind_analysis$idx_u)
     # res_u$Shat <- res_u$Shat%*%diag(sqrt(multfsusie.obj$sigma2$sd_u))
    }

  }

  if(is.null(Y$Y_f)){
    res_f <- NULL
  }else{
    if(missing(ind_analysis)){



        res_f <- lapply(1:length(Y$Y_f),
                        function(k) fsusieR:::cal_Bhat_Shat(Y$Y_f[[k]],
                                                                X       = X,
                                                                v1      = v1,
                                                                lowc_wc = low_trait$low_wc[[k]])


                      )

    }else{



        res_f <- lapply(1:length(Y$Y_f),
                        function(k) fsusieR:::cal_Bhat_Shat(Y$Y_f[[k]],
                                                                X       = X,
                                                                v1      = v1,
                                                                lowc_wc = low_trait$low_wc[[k]],
                                                                ind_analysis=ind_analysis$idx_f[[k]])
        )


    }

  }

 res  <- list( res_u = res_u,
               res_f   = res_f)

}






#' @title Compute conditional local false sign rate
#
#' @description Compute conditional local false sign rate
#'
#' @param G_prior multfsusie_prior
#
#' @param effect_estimate output of cal_Bhat_Shat_multfsusie
#'
#' @param list_indx_lst list of list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#'
#' @param \ldots other arguments
#'
#' @return esitmated conditional lfsr
#
#' @export


cal_clfsr <- function (G_prior, effect_estimate, list_indx_lst,...)
  UseMethod("cal_clfsr")


#' @rdname cal_clfsr
#
#' @method cal_clfsr multfsusie_prior
#
#' @export cal_clfsr.multfsusie_prior
#
#
#
#' @importFrom ashr set_data
#' @importFrom ashr get_fitted_g
#' @importFrom fsusieR cal_clfsr.mixture_normal_per_scale
#  @importFrom ashr calc_lfsr
#' @export
#

cal_clfsr.multfsusie_prior <- function(G_prior ,
                                       effect_estimate,
                                       list_indx_lst,...){

  if( ! is.null(effect_estimate$res_f)){
    clfsr_wc <- lapply(1: length(effect_estimate$res_f),
                       function(k){

                         fsusieR::cal_clfsr (
                           G_prior  = G_prior$G_prior_f[[k]],
                           Bhat     = effect_estimate$res_f[[k]]$Bhat,
                           Shat     = effect_estimate$res_f[[k]]$Shat,
                           indx_lst = list_indx_lst[[k]]
                         )

                       }
    )
  }else{
    clfsr_wc <- NULL
  }

  if( ! is.null(effect_estimate$res_u)){
    clfsr_u <- do.call(rbind,
                         lapply(1:ncol(effect_estimate$res_u$Bhat),
                                function(k){
                                  m <- G_prior$G_prior_u[[k]] [[1]]

                                  data_ash <-  ashr::set_data(
                                    effect_estimate$res_u$Bhat[,k],
                                    effect_estimate$res_u$Shat[,k])

                                  ashr:::calc_lfsr( m ,data_ash)
                                }
                         )
    )

  }else{
    clfsr_u <- NULL
  }

  clfsr_mult <- list( clfsr_wc   = clfsr_wc,
                      clfsr_u = clfsr_u)
  out <-  clfsr_mult
  return(out)

}











# @title Compute Log-Bayes Factor for univariate regression with ash prior
#
# @description Compute Log-Bayes Factor
#
# @param G_prior ash object
#
# @param Bhat p numerical vector of regression coefficients;
#
# @param Shat p numerical of standard errors;
# @return  The log-Bayes factor for each covariate.
#
# @export

log_BFu <- function (G_prior, Bhat, Shat,low_u=FALSE,df=NULL, ...) {


  Shat[ Shat<=0 ] <- 1e-32

  if( is.null(df)){
    if( low_u){
      out <- rep(0, length(Bhat))
    }else{
      tt   <- rep(0,length(Shat))
      pi_k <- G_prior$fitted_g$pi
      sd_k <- G_prior$fitted_g$sd
      # Speed Gain: could potential skip the one that are exactly zero.
      for (o in 1:length(G_prior$fitted_g$pi)){
        tt <- tt + pi_k[o] * stats::dnorm(Bhat ,sd = sqrt(sd_k[o]^2 + Shat ^2))
      }

      out <-  (log(tt) - stats::dnorm(Bhat ,sd = Shat ,log = TRUE))

    }
  }else{
    if( low_u){
      out <- rep(0, length(Bhat))
    }else{
      tt   <- rep(0,length(Shat))
      pi_k <- G_prior$fitted_g$pi
      sd_k <- G_prior$fitted_g$sd
      # Speed Gain: could potential skip the one that are exactly zero.
      for (o in 1:length(G_prior$fitted_g$pi)){
        tt <- tt + pi_k[o] *LaplacesDemon::dstp(Bhat,tau = 1/(sd_k[o]^2 + Shat ^2), nu=df)
      }

    }
    out <- sum(log(tt) - LaplacesDemon::dstp(Bhat ,tau = 1/Shat ^2,nu=df,log = TRUE))

  }



  return(out)
}

log_BF <- function( G_prior,effect_estimate ,list_indx_lst,low_trait , df=NULL )
  UseMethod("log_BF")

# @title Compute Log-Bayes Factor for a multiple f susie regression model
# @description Compute Log-Bayes Factor
#
# @param G_prior a multfsusie_prior
#
# @param effect_estimate regression coefficients generated by \link{\code{cal_Bhat_Shat_multfsusie}}
#
# @param  list_indx_lst List of lists generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
# @return  The log-Bayes factor for each covariate.
#
#' @export
#' @keywords internal
log_BF.multfsusie_prior <- function( G_prior,
                                     effect_estimate ,
                                     list_indx_lst,
                                     low_trait,
                                     df=NULL)
{
  if(is.null(df)){
    if( is.null(G_prior$G_prior_u)){
      u_logBF <- rep(0,nrow(effect_estimate$res_f[[1]]$Bhat  ))
    }else{
      u_logBF <-  lapply(1:ncol(effect_estimate$res_u$Bhat),
                         function(k)
                           log_BFu(G_prior = G_prior$G_prior_u[[k]],
                                   Bhat    =  effect_estimate$res_u$Bhat[,k] ,
                                   Shat    =  effect_estimate$res_u$Shat[,k],
                                   low_u   =  ifelse(k%in%low_trait$low_u, TRUE,FALSE)
                           )
      )
      u_logBF <- apply(do.call(rbind, u_logBF),2,sum)
    }
    if(is.null(G_prior$G_prior_f)){
      f_logBF <- rep(0,nrow(effect_estimate$res_u[[1]] ))
    }else{
      f_logBF <- lapply( 1: length(G_prior$G_prior_f) ,function( k)
        fsusieR::log_BF(G_prior  = G_prior$G_prior_f[[k]],
                            Bhat     = effect_estimate$res_f[[k]]$Bhat,
                            Shat     = effect_estimate$res_f[[k]]$Shat,
                            indx_lst = list_indx_lst[[k]],
                            lowc_wc  = low_trait$lowc_wc[[k]]
        )
      )
      f_logBF <- apply(do.call(rbind, f_logBF),2,sum)
    }

  }else{
    ### Work here ------
    if( is.null(G_prior$G_prior_u)){
      u_logBF <- rep(0,nrow(effect_estimate$res_f[[1]]$Bhat  ))
    }else{
     # print( "moderated BF u ")
      u_logBF <-  lapply(1:ncol(effect_estimate$res_u$Bhat),
                         function(k)
                           log_BFu(G_prior =  G_prior$G_prior_u[[k]],
                                   Bhat    =  effect_estimate$res_u$Bhat[,k] ,
                                   Shat    =  effect_estimate$res_u$Shat[,k],
                                   low_u   =  ifelse(k%in%low_trait$low_u, TRUE,FALSE),
                                   df      =  df$Y_u[k]
                           )
      )
      u_logBF <- apply(do.call(rbind, u_logBF),2,sum)
    }
    if(is.null(G_prior$G_prior_f)){
      f_logBF <- rep(0,nrow(effect_estimate$res_u[[1]] ))
    }else{
      #print( "moderated BF f ")
      f_logBF <- lapply( 1: length(G_prior$G_prior_f) ,function( k)
        fsusieR::log_BF(G_prior  = G_prior$G_prior_f[[k]],
                            Bhat     = effect_estimate$res_f[[k]]$Bhat,
                            Shat     = effect_estimate$res_f[[k]]$Shat,
                            indx_lst = list_indx_lst[[k]],
                            lowc_wc  = low_trait$lowc_wc[[k]],
                            df       = df$Y_f[k]
        )
      )
      f_logBF <- apply(do.call(rbind, f_logBF),2,sum)
    }



  }

  out <- f_logBF+u_logBF
  return(out)

}







# @title Compute posterior mean for univariate regression
# @description Compute posterior mean for univariate regression
# @param Bhat  a vector of mean estimate
# @param Bhat  a vector of sd estimate
# @param low_u logical indicate if the trait as critically low spread
get_post_mean_u <- function(G_prior, Bhat, Shat, low_u=FALSE)
{
  if(low_u){
    return(rep( 0, length(Bhat)))
  }else{
    data <-  ashr::set_data(Bhat  ,Shat  )
    return(ashr::postmean(ashr::get_fitted_g(G_prior),data))
  }

}


# @title Compute posterior sd for univariate regression
# @description Compute posterior sd for univariate regression
# @param Bhat  a vector of mean estimate
# @param Bhat  a vector of sd estimate
# @param low_u logical indicate if the trait as critically low spread
get_post_sd_u <- function(G_prior, Bhat, Shat, low_u=FALSE)
{
  if(low_u){
    return(rep( 1, length(Bhat)))
  }else{
  data <-  ashr::set_data(Bhat  ,Shat  )
  return(ashr::postsd(ashr::get_fitted_g(G_prior),data))
  }
}


#' @title  Compute Residual variance
#' @description  see title
#' @param multfsusie.obj a multfsusie object
#' @param Y observed response data
#' @param X observed covariates
#' @export
#' @keywords internal
estimate_residual_variance <- function(multfsusie.obj,Y,X,... )
  UseMethod("estimate_residual_variance")



#' @rdname estimate_residual_variance
#
#' @method estimate_residual_variance multfsusie
#
#' @export estimate_residual_variance.multfsusie
#
#' @export
#' @keywords internal
estimate_residual_variance.multfsusie <- function(multfsusie.obj,Y,X, ind_analysis, ... )
{
  if (missing(ind_analysis)){
    R2 <- get_ER2( multfsusie.obj, Y, X)
    est_sd2 <-  list()
    if(!is.null(R2$uni))
    {
      est_sd2$sd_u <-  R2$uni/nrow(Y$Y_u)
    }
    if(!is.null(R2$f)){
      n <- rep(nrow(Y$Y_f[[1]]), length(Y$Y_f) )
      t <- do.call( c, lapply(1: length(Y$Y_f), function(k) ncol(Y$Y_f[[k]] ) ))
      est_sd2$sd_f <- R2$f / (n*t)
    }

  }else{
    R2 <- get_ER2( multfsusie.obj, Y, X, ind_analysis)
    est_sd2 <-  list()
    if(!is.null(R2$uni))
    {
      est_sd2$sd_u <-  R2$uni/(nrow(Y$Y_u)- (  nrow(Y$Y_u) - lengths(ind_analysis$idx_u) ))# accounting for missing data points
    }
    if(!is.null(R2$f)){# accounting for missing data points
      n <-  do.call(c,  lapply( 1: length(Y$Y_f), function( k) (nrow(Y$Y_f[[k]])- ( nrow(Y$Y_f[[k]]) - length(ind_analysis$idx_f[[k]]) ))))
      t <- do.call( c, lapply(1: length(Y$Y_f), function(k) ncol(Y$Y_f[[k]] ) ))
      est_sd2$sd_f <- R2$f / (n*t)
    }

  }





  out <-  est_sd2
  return(out)
}






#@title Function to fit entry-wise lm on tensor regression
#
#@param l  wavelet coefficient index
#@param j  covariate index
#@param xi condition index
#@param Y observed tensor
#@param X observed covariate
# @export
parse_lm_fit <- function(j,l,xi, v1,Y,X)
{

  out <- fast_lm(cbind(v1,X[,j]),Y[,l,xi])
  return(c(out$be[2,1],
           sqrt(
             Rfast::cova(out$residuals)/sum(
               (X[,j]-mean(X[,j]))^2)
           )
  )
  )
}

