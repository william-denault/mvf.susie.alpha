






# @title EM algorithm to select mixture weight in a  Empirical Bayes way for multSuSiE
#
# @description Select the mixture weight by maximizing the marginal likelihood
#
#
# @param G_prior a multfsusie_prior
#
# @param effect_estimate a list of marginal association generated by \code{cal_Bhat_Shat_multsusie}
#
# @param  list_indx_lst List of lists generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
#
# @param max_step numeric, maximum number of EM iteration
#
#
# @param espsilon numeric, tolerance EM algorithm
#
# @return
#\item{tpi_k}{ fitted mixture proportion}
#\item{lBF}{ log Bayes Factor}
#
# @export
#
EM_pi_multsusie <- function(G_prior,effect_estimate, list_indx_lst,
                            max_step = 100,
                            espsilon = 0.0001,
                            init_pi0_w= 0.9,
                            control_mixsqp ,
                            nullweight,
                            low_trait,
                            max_SNP_EM=1000,
                            df=NULL)
{

  ### Work here ------

  lBF <- log_BF(G_prior,
                effect_estimate = effect_estimate,
                list_indx_lst   = list_indx_lst,
                low_trait       = low_trait ,
                df              = df)




  if( !is.null(effect_estimate$res_uni)){
    J <- nrow( effect_estimate$res_uni$Bhat)
  }else{
    J <- nrow( effect_estimate$res_f[[1]]$Bhat)
  }


  if( length(lBF)> max_SNP_EM){ # basically allow running EM only on data point with most signal
    idx <- order(lBF, decreasing =  TRUE)[1:ceiling(max_SNP_EM)]

  }else{
    idx <- 1:length(lBF)
  }

  L_mat  <- L_mixsq_multsusie (G_prior, effect_estimate, list_indx_lst,idx=idx)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration


  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- fsusieR::cal_lik(lBF,zeta)
    zeta      <- fsusieR::cal_zeta(lBF)

    # M step ----
    tpi_k   <- m_step_multsusie(L_mat          = L_mat,
                                zeta           = zeta[idx] ,
                                list_indx_lst  = list_indx_lst,
                                init_pi0_w     = init_pi0_w,
                                control_mixsqp = control_mixsqp,
                                nullweight     = nullweight)
    G_prior <- update_prior(G_prior,tpi_k)

    lBF <- log_BF(G_prior,
                  effect_estimate = effect_estimate,
                  list_indx_lst   = list_indx_lst,
                  low_trait       = low_trait ,
                  df              = df)
    lBF <- ifelse(lBF==-Inf,0,lBF)
    newloglik <- fsusieR::cal_lik(lBF,zeta)
    k <- k+1

  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi_multfsusie","list")
  return(out)
}





L_mixsq_multsusie <- function(G_prior, effect_estimate, list_indx_lst,idx ) {

  if(is.null(G_prior$G_prior_u)){
    L_mat_u <- NULL
  }else{
    L_mat_u <- lapply( 1: length(G_prior$G_prior_u) ,function( k)
      L_mixsq_u(G_prior$G_prior_u[[k]],
                Bhat = effect_estimate$res_u$Bhat[idx,k],
                Shat = effect_estimate$res_u$Shat[idx,k]
      )
    )

  }
  if(is.null(G_prior$G_prior_f)){
    L_mat_f <- NULL
  }else{
    L_mat_f <- lapply( 1: length(G_prior$G_prior_f) ,function( k)
      fsusieR::L_mixsq(G_prior$G_prior_f[[k]],
                           Bhat     = effect_estimate$res_f[[k]]$Bhat[idx,],
                           Shat     = effect_estimate$res_f[[k]]$Shat[idx,],
                           indx_lst = list_indx_lst[[k]]
      )
    )

  }
  L_mat <- list(L_mat_u=L_mat_u,
                L_mat_f=L_mat_f)
  attr(L_mat,"class") <- "lik_multfsusie"
  return(L_mat)
}

# @title Compute Log-Bayes Factor for univariate regression with ash prior
#
# @description Compute Log-Bayes Factor
#
# @param G_prior ash object
#
# @param Bhat p numerical vector of regression coefficients;
#
# @param Shat p numerical of standard errors;
# @return See L argument mixsqp package mixsqp function
#
# @export
L_mixsq_u <- function(G_prior, Bhat, Shat){
  m     <-  (G_prior )
  sdmat <- outer(c(Shat ^2), m$fitted_g$sd^2,"+")
  L     <- (
    stats:: dnorm(
                 outer(
                        c(Bhat),
                        rep(0,length(m$fitted_g$sd)),
                         FUN="-"
                       )/sdmat,
                log=TRUE
              ) -log(sdmat )
          )
  L <- rbind(c(0, rep( -100,(ncol(L)-1)  )),#adding penalty line
             L)
  class(L) <- "lik_mixture_normal"
  return(L)
}




# @title Compute M step in the weighted ash  problem
#
# @description Add description here.
#
# @param L output of  \code{\link{L_mixsq_multsusie}} function
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
# @param nullweight
#
# @return a list of proportion (class pi_mixture_normal)
#
# @export

m_step_multsusie <- function(L_mat, zeta, list_indx_lst, init_pi0_w,  control_mixsqp,nullweight,...)
{
  #setting the weight to fit the weighted ash problem
  if (is.null(L_mat$L_mat_u)){
    est_pi_u <- NULL
  }else{
    est_pi_u <- lapply(1:length(L_mat$L_mat_u) ,
                       function(k) m_step_u (L_mat$L_mat_u[[k]],
                                             zeta,
                                             init_pi0_w     = init_pi0_w,
                                             control_mixsqp = control_mixsqp,
                                             nullweight     = nullweight)
    )
  }
  if (is.null(L_mat$L_mat_f)){
    est_pi_f <- NULL
  }else{
    est_pi_f <- lapply(1:length(L_mat$L_mat_f) ,
                       function(k)fsusieR::m_step(L_mat$L_mat_f[[k]],
                                                      zeta=zeta ,
                                                      indx_lst=list_indx_lst[[k]],
                                                      init_pi0_w= init_pi0_w,
                                                      control_mixsqp = control_mixsqp,
                                                      nullweight     = nullweight
                       )
    )
  }

  out <- list(est_pi_u= est_pi_u,
              est_pi_f = est_pi_f
  )
  attr(out, "class") <- "pi_multfsusie"
  return(out)

}






# @title Compute M step in the weighted ash  problem for univariate regression
#
# @description Add description here.
#
# @param L output of  \code{\link{L_mixsq_multsusie}} function
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#
# @return a list of proportion (class pi_mixture_normal)
#
# @export

m_step_u <- function  (L, zeta , init_pi0_w , control_mixsqp,nullweight, ...)
{
  w <-c(nullweight,zeta) # setting the weight to fit the weighted ash problem
  tlength <- ncol(L) - 1
  mixsqp_out <- mixsqp::mixsqp(L,
                                w,
                                log = TRUE,
                                x0 = c(init_pi0_w ,rep(1e-12,tlength)), # put starting point close to sparse solution
                                control = control_mixsqp
  )
  out <- mixsqp_out$x
  class(out) <-  "pi_mixture_normal"
  return(out)
}

