

# @title EM algorithm to select mixture weight in a  Empirical Bayes way for multivariate SuSiE
#
# @description Select the mixture weight by maximizing the marginal likelihood
#
#
# @param G_prior a scale specific mash prior
#
# @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#
# @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
#
# @param max_step numeric, maximum number of EM iteration
#
#
# @param espsilon numeric, tolerance EM algorithm
#
# @return
#\item{tpi_k}{ fitted mixture proportion}
#\item{lBF}{ log Bayes Factor}
#
# @export
#
EM_pi_mvfsusie <- function(G_prior,tens_marg, list_indx_lst, init_pi0_w,  control_mixsqp,nullweight,
                           max_step = 100,
                           espsilon = 0.0001){

  #static parameters
  Lmat  <-  L_mixsq_mvfsusie(G_prior, tens_marg, indx_lst)
  J <- dim(tens_marg$tens_Bhat)[1]

  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration

  lBF <- log_BF_tens  ( G_prior, tens_marg, indx_lst)

  while( k <=max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- cal_lik_mvfsusie (lBF,zeta)
    #zeta      <- cal_zeta_mvfsusie(lBF)

    # M step ----
    tpi_k   <- m_step_mvfsusie(Lmat,
                               zeta,
                               list_indx_list= list_indx_lst,
                               init_pi0_w=init_pi0_w,
                               control_mixsqp=control_mixsqp,
                               nullweight=nullweight)
    G_prior <- update_prior_weight_mvfsusie(G_prior,tpi_k)

    lBF <- log_BF_tens  ( G_prior, tens_marg, indx_lst)
    newloglik <- cal_lik_mvfsusie(lBF,zeta)
    k <- k+1
    #newloglik
    # oldloglik
    # lBF
  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi_mvfsusie","list")
  return(out)
}

#@title Compute likelihood matrix for mixsqp
#
# @description Compute likelihood matrix for mixsqp
#
# @param G_prior a scale specific mash prior
#
# @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#
# @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
#
# @return See L argument mixsqp package mixsqp function
#
# @export
L_mixsq_mvfsusie <- function(G_prior, tens_marg, indx_lst)
{
  L <- lapply( 1:length(indx_lst), function(s) L_mixsq_mvfsusie_scale(G_prior, tens_marg, indx_lst,s))
  return(L)
}


#@title Compute likelihood matrix for mixsqp
#
# @description Compute likelihood matrix for mixsqp
#
# @param G_prior a scale specific mash prior
#
# @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#
# @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
#
# @param s scale of interest
#
# @return a matrix of scale specific log likelihood value
# @export
L_mixsq_mvfsusie_scale <- function(G_prior, tens_marg, indx_lst,s)
{
  grid   <-  get_grid (G_prior , s)
  Ulist  <-  get_Ulist (G_prior , s)

  Bhat   <-  cbind_3Darray(tens_marg$tens_Bhat[,indx_lst[[s]],])
  Shat   <-  cbind_3Darray(tens_marg$tens_Shat[,indx_lst[[s]],])
  data   <-  mashr::mash_set_data( Bhat,  Shat)
  xUlist <-  utils::getFromNamespace("expand_cov", "mashr")(Ulist,grid,usepointmass=TRUE)



  L_mat  <-  utils::getFromNamespace("calc_relative_lik_matrix", "mashr")(data = data, xUlist) # allow using unexported function

  return(L_mat$loglik_matrix)
}




# @title Compute M step in the weighted mashr problem
#
# @description Add description here.
#
# @param L output of  \code{\link{L_mixsq_mvfsusie}} function
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#
# @return a list of proportion (class pi_mixture_normal)
#
# @export

m_step_mvfsusie <- function(L, zeta, indx_lst, ...)
{
  #setting the weight to fit the weighted ash problem


  out <- lapply(1:length(indx_lst) ,
                function(s) scale_m_step_mvfsusie(L,s,zeta,indx_lst)
  )

  return(out)

}

#@title Subroutine to compute M step in the weighted mash problem for normal mixture prior per scale
#
# @description  Subroutine to compute M step in the weighted mash
#
# @param L output of the L_mixsqp.mixture_normal_per_scale function
#
# @param s scale
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#
# @return a vector of proportion for the scale s
#
# @importFrom mixsqp mixsqp
#
# @export
scale_m_step_mvfsusie <- function(L,s,zeta, indx_lst)
{
  w <- rep(zeta,length(indx_lst[[s]] ))
  tlength <- dim(L[[s]])[2]-1
  mixsqp_out <- mixsqp::mixsqp( L[[s]] ,
                        w,
                        #x0 = c(1, rep(1e-1,  tlength )),
                        log=TRUE ,
                        control = list(
                          eps = 1e-6,
                          numiter.em = 40,
                          verbose=FALSE
                        )
  )

  out <- mixsqp_out$x
  return( out)

}



# @title Compute assignment probabilities from log Bayes factors
#
# @description  Compute assignment probabilities from log Bayes factors
#
# @param lBF vector of log Bayes factors

cal_zeta_mvfsusie <- function(lBF)
{
  out <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))
  return(out)
}


# @title Compute likelihood for the weighted mash problem
#
# @description Compute likelihood for the weighted mash problem
#
# @param lBF vector of log Bayes factors
#
# @param zeta assignment probabilities
#
# @return Likelihood value
#
# @export
#
cal_lik_mvfsusie <- function(lBF,zeta)
{
  out <- sum( zeta*exp(lBF - max(lBF ) ))
  return(out)
}








# @title EM algorithm to select mixture weight in a  Empirical Bayes way for multSuSiE
#
# @description Select the mixture weight by maximizing the marginal likelihood
#
#
# @param G_prior a multfsusie_prior
#
# @param effect_estimate a list of marginal association generated by \code{cal_Bhat_Shat_multsusie}
#
# @param  list_indx_lst List of lists generated by \code{\link{gen_wavelet_indx}}
#   for the given level of resolution
#
# @param max_step numeric, maximum number of EM iteration
#
#
# @param espsilon numeric, tolerance EM algorithm
#
# @return
#\item{tpi_k}{ fitted mixture proportion}
#\item{lBF}{ log Bayes Factor}
#
# @export
#
EM_pi_multsusie <- function(G_prior,effect_estimate, list_indx_lst,
                            max_step = 100,
                            espsilon = 0.0001,
                            init_pi0_w= 0.9,
                            control_mixsqp ,
                            nullweight,
                            low_trait,
                            max_SNP_EM=1000)
{



  lBF <- log_BF(G_prior,
                effect_estimate = effect_estimate,
                list_indx_lst   = list_indx_lst,
                low_trait       = low_trait )




  if( !is.null(effect_estimate$res_uni)){
    J <- nrow( effect_estimate$res_uni$Bhat)
  }else{
    J <- nrow( effect_estimate$res_f[[1]]$Bhat)
  }


  if( length(lBF)> max_SNP_EM){ # basically allow running EM only on data point with most signal
    idx <- order(lBF, decreasing = FALSE)[1:ceiling(max_SNP_EM)]

  }else{
    idx <- 1:length(lBF)
  }

  L_mat  <- L_mixsq_multsusie (G_prior, effect_estimate, list_indx_lst,idx=idx)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration


  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- susiF.alpha::cal_lik(lBF,zeta)
    zeta      <- susiF.alpha::cal_zeta(lBF)

    # M step ----
    tpi_k   <- m_step_multsusie(L_mat          = L_mat,
                                zeta           = zeta[idx] ,
                                list_indx_lst  = list_indx_lst,
                                init_pi0_w     = init_pi0_w,
                                control_mixsqp = control_mixsqp,
                                nullweight     = nullweight)
    G_prior <- update_prior(G_prior,tpi_k)

    lBF <- log_BF(G_prior,
                  effect_estimate = effect_estimate,
                  list_indx_lst   = list_indx_lst,
                  low_trait       = low_trait )
    lBF <- ifelse(lBF==-Inf,0,lBF)
    newloglik <- susiF.alpha::cal_lik(lBF,zeta)
    k <- k+1

  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi_multfsusie","list")
  return(out)
}





L_mixsq_multsusie <- function(G_prior, effect_estimate, list_indx_lst,idx ) {

  if(is.null(G_prior$G_prior_u)){
    L_mat_u <- NULL
  }else{
    L_mat_u <- lapply( 1: length(G_prior$G_prior_u) ,function( k)
      L_mixsq_u(G_prior$G_prior_u[[k]],
                Bhat = effect_estimate$res_u$Bhat[idx,k],
                Shat = effect_estimate$res_u$Shat[idx,k]
      )
    )

  }
  if(is.null(G_prior$G_prior_f)){
    L_mat_f <- NULL
  }else{
    L_mat_f <- lapply( 1: length(G_prior$G_prior_f) ,function( k)
      susiF.alpha::L_mixsq(G_prior$G_prior_f[[k]],
                           Bhat     = effect_estimate$res_f[[k]]$Bhat[idx,],
                           Shat     = effect_estimate$res_f[[k]]$Shat[idx,],
                           indx_lst = list_indx_lst[[k]]
      )
    )

  }
  L_mat <- list(L_mat_u=L_mat_u,
                L_mat_f=L_mat_f)
  attr(L_mat,"class") <- "lik_multfsusie"
  return(L_mat)
}

# @title Compute Log-Bayes Factor for univariate regression with ash prior
#
# @description Compute Log-Bayes Factor
#
# @param G_prior ash object
#
# @param Bhat p numerical vector of regression coefficients;
#
# @param Shat p numerical of standard errors;
# @return See L argument mixsqp package mixsqp function
#
# @export
L_mixsq_u <- function(G_prior, Bhat, Shat){
  m     <-  (G_prior )
  sdmat <- sqrt(outer(c(Shat ^2), m$fitted_g$sd^2,"+"))
  L     <- (
    dnorm(
      outer(
        c(Bhat),
        rep(0,length(m$fitted_g$sd)),
        FUN="-"
      )/sdmat,
      log=TRUE
    ) -log(sdmat )
  )
  L <- rbind(c(0, rep( -100,(ncol(L)-1)  )),#adding penalty line
             L)
  class(L) <- "lik_mixture_normal"
  return(L)
}




# @title Compute M step in the weighted ash  problem
#
# @description Add description here.
#
# @param L output of  \code{\link{L_mixsq_multsusie}} function
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
# @param nullweight
#
# @return a list of proportion (class pi_mixture_normal)
#
# @export

m_step_multsusie <- function(L_mat, zeta, list_indx_lst, init_pi0_w,  control_mixsqp,nullweight,...)
{
  #setting the weight to fit the weighted ash problem
  if (is.null(L_mat$L_mat_u)){
    est_pi_u <- NULL
  }else{
    est_pi_u <- lapply(1:length(L_mat$L_mat_u) ,
                       function(k) m_step_u (L_mat$L_mat_u[[k]],
                                             zeta,
                                             init_pi0_w     = init_pi0_w,
                                             control_mixsqp = control_mixsqp,
                                             nullweight     = nullweight)
    )
  }
  if (is.null(L_mat$L_mat_f)){
    est_pi_f <- NULL
  }else{
    est_pi_f <- lapply(1:length(L_mat$L_mat_f) ,
                       function(k)susiF.alpha::m_step(L_mat$L_mat_f[[k]],
                                                      zeta=zeta ,
                                                      indx_lst=list_indx_lst[[k]],
                                                      init_pi0_w= init_pi0_w,
                                                      control_mixsqp = control_mixsqp,
                                                      nullweight     = nullweight
                       )
    )
  }

  out <- list(est_pi_u= est_pi_u,
              est_pi_f = est_pi_f
  )
  attr(out, "class") <- "pi_multfsusie"
  return(out)

}






# @title Compute M step in the weighted ash  problem for univariate regression
#
# @description Add description here.
#
# @param L output of  \code{\link{L_mixsq_multsusie}} function
#
# @param zeta assignment probabilities for each covariate
#
# @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#
# @return a list of proportion (class pi_mixture_normal)
#
# @export

m_step_u <- function  (L, zeta , init_pi0_w , control_mixsqp,nullweight, ...)
{
  w <-c(nullweight,zeta) # setting the weight to fit the weighted ash problem
  tlength <- ncol(L) - 1
  mixsqp_out <- mixsqp::mixsqp(L,
                                w,
                                log = TRUE,
                                x0 = c(init_pi0_w ,rep(1e-12,tlength)), # put starting point close to sparse solution
                                control = control_mixsqp
  )
  out <- mixsqp_out$x
  class(out) <-  "pi_mixture_normal"
  return(out)
}

