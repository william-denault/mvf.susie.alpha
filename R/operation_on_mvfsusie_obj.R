


#' @title Compute partial residual for effect l
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @param X matrix of covariate
#'
#' @param D tensor of wavelet coefficients from the original input data (Y)
#'
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'
#' @return a tensor of size N, J, Xi( number of conditions) of partial residuals
#'
#' @export
cal_partial_resid  <- function( mvfsusie.obj, l, X, D, indx_lst, ... )
  UseMethod("cal_partial_resid")


#' @rdname cal_partial_resid
#'
#' @method cal_partial_resid mvfsusie
#'
#' @export cal_partial_resid.mvfsusie
#'
#' @export
#'

cal_partial_resid.mvfsusie  <- function( mvfsusie.obj, l, X, D, indx_lst, ... )
{
  L <- mvfsusie.obj$L
  if (L > 1){
    id_L <- (1:L)[ - ( (l%%L)+1) ]#Computing residuals R_{l+1} by removing all the effect except effect l+1


      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) (X*rep(mvfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %x% (mvfsusie.obj$fitted_wc[[l]])   ) )


  }else{
    id_L <- 1


    update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) (X*rep(mvfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %x% (mvfsusie.obj$fitted_wc[[l]])   ) )


  }


  return(update_D)
}




#' @title Initialize a mvfsusie object
#'
#' @param L number of non zero coefficients An L-vector containing the indices of the
#'   nonzero coefficients.
#'
#' @param G_prior prior object defined by init_prior_mvfsusie function
#'
#' @param Y tensor matrix of outcomes
#'
#' @param X Matrix of covariates
#'
#' @return A list with the following elements
#' \item{fitted_wc}{ list of length L, each element contains the fitted wavelet coefficients of effect l}
#' \item{fitted_wc2}{list of length L, each element contains the variance of the fitted wavelet coefficients of effect l}
#' \item{alpha_hist}{ history of the fitted alpha value}
#' \item{N}{ number of indidivual in the study}
#' \item{sigma2}{residual variance}
#' \item{n_wac}{number of wavelet coefficients}
#' \item{ind_fitted_func}{fitted curves of each individual }
#' \item{cs}{credible set}
#' \item{pip}{Posterior inclusion probabilites}
#' \item{G_prior}{a G_prior of the same class as the input G_prior, used for internal calculation}
#' \item{lBF}{ log Bayes factor for the different effect}
#' \item{KL}{ the KL divergence for the different effect}
#' \item{ELBO}{ The evidence lower bound}
#' \item{lfsr_wc}{Local fasle sign rate of the fitted wavelet coefficients}
#' @export
init_mvfsusie_obj <- function(L, G_prior, Y,X )
{


  fitted_wc       <-  list()
  fitted_wc2      <-  list()
  alpha           <-  list()
  alpha_hist      <-  list()
  ind_fitted_func <-  array(0, dim= c(dim(Y)) )
  cs              <-  list()
  pip             <-  rep(0, dim(X)[2])
  est_pi          <-  list()
  est_sd          <-  list()
  lfsr_wc         <-  list()
  lfsr_func       <-  list()
  L               <-  L
  G_prior         <-  G_prior
  N               <-  dim(Y)[1]
  n_wac           <-  dim(Y)[2]
  n_cond          <-  dim(Y)[3]
  P               <-  dim(X)[2]
  sigma2          <-  1
  lBF             <-  list()
  KL              <-  rep(NA,L)
  ELBO            <-  c()
  for ( l in 1:L )
  {
    fitted_wc[[l]]        <-  array(0, dim= c(dim(X)[2], ncol=dim(Y)[2], dim(Y)[3])  )
    fitted_wc2[[l]]       <-  array(0, dim= c(dim(X)[2], ncol=dim(Y)[2], dim(Y)[3])  )
    alpha [[l]]           <-  rep(0, dim(X)[2])
    cs[[l]]               <-  list()
    est_pi [[l]]          <-  get_pi_G_prior(G_prior)
    lBF[[l]]              <-  rep(NA, ncol(X))
    lfsr_wc[[l]]          <-  rep(1, ncol(Y))
    lfsr_func[[l]]        <-  rep(1, ncol(Y))
  }
  obj <- list( fitted_wc       = fitted_wc,
               fitted_wc2      = fitted_wc2,
               lfsr_wc         = lfsr_wc,
               lBF             = lBF,
               KL              = KL,
               ELBO            = ELBO,
               ind_fitted_func = ind_fitted_func,
               G_prior         = G_prior,
               alpha_hist      = alpha_hist,
               N               = N,
               n_wac           = n_wac,
               sigma2          = sigma2,
               P               = P,
               alpha           = alpha,
               cs              = cs,
               pip             = pip,
               est_pi          = est_pi,
               est_sd          = est_sd,
               L               = L)

  class(obj) <- "mvfsusie"
  return(obj)
}


#'
#'@title Access mvfmvfsusie internal prior
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @return G_prior a mash_per_scale object

#'
get_G_prior  <- function(mvfsusie.obj.obj, ...)
  UseMethod("get_G_prior")


#' @rdname get_G_prior
#'
#' @method get_G_prior mvfsusie
#'
#' @export get_G_prior.mvfsusie
#'
#' @export
#'
get_G_prior.mvfsusie <- function(mvfsusie.obj, ...)
{
  out <- mvfsusie.obj$G_prior
  class(out) <- 'mash_per_scale'
  return(out)
}



#'
#' @title Access mvfsusie mixture proportion of effect l
#'
#' @param mvfsusie a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @return a list of  vector of proportion
#'
#' @export
#'
get_pi  <- function(mvfsusie, l, ...)
  UseMethod("get_pi")

#' @rdname get_pi
#'
#' @method get_pi mvfsusie
#'
#' @export get_pi.mvfsusie
#'
#' @export
#'
get_pi.mvfsusie <- function(mvfsusie, l, ...)
{

  if( l >  length(mvfsusie$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  out <- mvfsusie$est_pi[[l]]
  return(out)
}








#' @title Preparing output of main mvfsusie function
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, mvfsusie internally remaps the data into a grid of length 2^J
#'
#' @param X matrix of size N by p
#'
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'
#' @param filter.cs logical, if TRUE filter the credible set (removing low purity cs and cs with estimated prior equal to 0)
#'
#' @param lfsr_curve Maximum local false sign rate of the wavelet coefficients used to reconstruct lfsr_curves (see output)
#' @return mvfsusie object
#'
#' @export
#'
out_prep <- function(mvfsusie.obj,Y, X, indx_lst, filter.cs, lfsr_curve, ...)
  UseMethod("out_prep")

#' @rdname out_prep
#'
#' @method out_prep mvfsusie
#'
#' @export out_prep.mvfsusie
#'
#' @export
#'

out_prep.mvfsusie <- function(mvfsusie.obj,Y, X, indx_lst, filter.cs, lfsr_curve, ...)
{
  mvfsusie.obj <-  update_cal_pip(mvfsusie.obj)
  mvfsusie.obj <-  update_cal_cs(mvfsusie.obj)
  mvfsusie.obj <-  update_cal_fit_func(mvfsusie.obj, indx_lst)
  if(filter.cs)
  {
    mvfsusie.obj <- check_cs(mvfsusie.obj)
  }
  mvfsusie.obj <-  update_cal_indf(mvfsusie.obj, Y, X, indx_lst)
  mvfsusie.obj <-  update_cal_lfsr_func(mvfsusie.obj, lfsr_curve, indx_lst)

  return(mvfsusie.obj)
}






#' @title Update mvfsusie by computing posterior curves
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, mvfsusie internally remaps the data into grid of length 2^J
#'
#' @param X matrix of size N by p
#'
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'
#' @return mvfsusie object
#'
#' @export
update_cal_fit_func  <- function(mvfsusie.obj, indx_lst, ...)
  UseMethod("update_cal_fit_func")

#' @rdname update_cal_fit_func
#'
#' @method update_cal_fit_func mvfsusie
#'
#' @export update_cal_fit_func.mvfsusie
#'
#' @importFrom wavethresh wr
#'
#' @importFrom wavethresh wd
#'
#' @export
#'

update_cal_fit_func.mvfsusie <- function(mvfsusie.obj, indx_lst, ...)
{

  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }

  temp_wd.obj <- wd(rep(0, mvfsusie.obj$n_wac))
    for ( l in 1:mvfsusie.obj$L)
    {
      temp <- (matrix( 1,ncol= ncol(X),nrow= nrow(X)) *rep(mvfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %x% (mvfsusie.obj$fitted_wc[[l]])


   #create dummy wd object

      mvfsusie.obj$fitted_func[[l]] <-  wr_tens(tens=temp,
                                                temp_wd.obj=temp_wd.obj,
                                                indx_lst =  indx_lst,
                                                out_dim = dim(  temp ))[1, 1:mvfsusie.obj$n_wac,1:dim(temp)[3]]
    }

  return(mvfsusie.obj)
}







#'@title Update mvfsusie by computing predicted curves
#'
#'@param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'@param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, mvfsusie internally remaps the data into grid of length 2^J
#'@param X matrix of size N by p
#'#'@param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'@return mvfsusie object
#'@export
#'

update_cal_indf <- function(mvfsusie.obj, Y, X, indx_lst, ...)
  UseMethod("update_cal_indf")

#' @rdname update_cal_indf
#'
#' @method update_cal_indf mvfsusie
#'
#' @export update_cal_indf.mvfsusie
#'
#' @importFrom wavethresh wr
#'
#' @importFrom wavethresh wd
#'
#' @export
#'

update_cal_indf.mvfsusie <- function(mvfsusie.obj, Y, X, indx_lst, ...)
{
  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
   temp_wd.obj <- wd(rep(0, mvfsusie.obj$n_wac)) #create dummy wd object
   L <- mvfsusie.obj$L
   temp  <-  Reduce("+", lapply  ( 1:L, function(l) (X*rep(mvfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %x% (mvfsusie.obj$fitted_wc[[l]])   ) )
   mvfsusie.obj$ind_fitted_func <-  wr_tens( temp ,
                                            temp_wd.obj=temp_wd.obj,
                                            indx_lst =  indx_lst,
                                            out_dim = dim(  temp )
                                            )

  return( mvfsusie.obj)
}





#'@title Update mvfsusie by computing PiP
#'
#'@param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'@return mvfsusie object
#'@export

update_cal_pip  <- function (mvfsusie.obj, ...)
  UseMethod("update_cal_pip")

#' @rdname update_cal_pip
#'
#' @method update_cal_pip mvfsusie
#'
#' @export update_cal_pip.mvfsusie
#'
#' @export
#'

update_cal_pip.mvfsusie <- function (mvfsusie.obj, ...)
{
  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  tpip <- list()
  for ( l in 1:mvfsusie.obj$L)
  {
    tpip[[l]] <- rep(1, lengths(mvfsusie.obj$alpha)[[l]])-mvfsusie.obj$alpha[[l]]
  }
  mvfsusie.obj$pip <- 1-  apply( do.call(rbind,tpip),2, prod)
  return(mvfsusie.obj)
}


#'@title Update mvfsusie by computing credible sets
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param cov_lev numeric between 0 and 1, corresponding to the expected level of coverage of the cs if not specified set to 0.95
#'
#' @return mvfsusie object
#'
#' @export

update_cal_cs  <- function(mvfsusie.obj, cov_lev=0.95, ...)
  UseMethod("update_cal_cs")

#' @rdname update_cal_cs
#'
#' @method update_cal_cs mvfsusie
#'
#' @export update_cal_cs.mvfsusie
#'
#' @export
#'

update_cal_cs.mvfsusie <- function(mvfsusie.obj, cov_lev=0.95)
{
  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  for ( l in 1:mvfsusie.obj$L)
  {
    temp        <- mvfsusie.obj$alpha[[l]]
    temp_cumsum <- cumsum( temp[order(temp, decreasing =TRUE)])
    max_indx_cs <- min(which( temp_cumsum >cov_lev ))
    mvfsusie.obj$cs[[l]]  <- order(temp, decreasing = TRUE)[1:max_indx_cs ]

  }

  return(mvfsusie.obj)
}



#'@title Update  mvfsusie object using the output of EM_pi
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj }} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @param EM_pi an object of the class "EM_pi" generated by the function \code\link{EM_pi_mvfsusie}}
#' @param tens_marg an object containning regression coefficients, generated from \link{\code{cal_Bhat_Shat_tensor}}
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#
#' @return mvfsusie object
#'
#' @export

update_mvfsusie  <- function(mvfsusie.obj, l, EM_pi, tens_marg, indx_lst, all=FALSE ,...)
{

  if( l > length(mvfsusie.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  if(  "EM_pi_mvfsusie"  %!in%  class(EM_pi)  )
  {
    stop("Error EM_pi should be of the class EM_pi_mvfsusie")
  }
  mvfsusie.obj         <-   update_pi( mvfsusie.obj =  mvfsusie.obj ,
                                      l             =  l ,
                                      tpi           =  EM_pi$tpi_k)

  mvfsusie.obj$G_prior    <-   update_prior_weight_mvfsusie (get_G_prior(mvfsusie.obj) , EM_pi$tpi_k  )

  post_tens_res <- get_post_tens (G_prior=mvfsusie.obj$G_prior ,
                                  tens_marg,
                                  indx_lst,
                                  all = all)


  mvfsusie.obj$fitted_wc[[l]]   <- post_tens_res$post_mean_tens
  mvfsusie.obj$fitted_wc2[[l]]  <- post_tens_res$post_sd_tens

  new_alpha    <- cal_zeta_mvfsusie(  EM_pi$lBF)
  mvfsusie.obj <- update_alpha(mvfsusie.obj, l, new_alpha)
  mvfsusie.obj <- update_lBF(mvfsusie.obj, l, EM_pi$lBF)
  if(all)
  {
    mvfsusie.obj <- update_lfsr (mvfsusie.obj, l, post_tens_res)

  }

  return(mvfsusie.obj)
}


#' @title Update alpha   mvfsusie  mixture proportion of effect l
#'
#' @param mvfsusie.obj a  mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @param alpha  vector of p alpha values summing up to one
#'
#' @return  mvfsusie object
#'
#' @export
#'

update_alpha  <-  function(mvfsusie.obj, l, alpha, ... )
  UseMethod("update_alpha")


#' @rdname update_alpha
#'
#' @method update_alpha mvfsusie
#'
#' @export update_alpha.mvfsusie
#'
#' @export
#'
update_alpha.mvfsusie <-  function(mvfsusie.obj, l, alpha, ... )
{
  mvfsusie.obj$alpha[[l]] <- alpha
  mvfsusie.obj$alpha_hist[[ (length(mvfsusie.obj$alpha_hist)+1)  ]] <- alpha
  return( mvfsusie.obj)
}





#' @title Update mixture proportion of mvfsusie mixture proportions of effect l
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @param tpi an object of class  "pi_mixture_mash_per_scale"
#'
#' @return mvfsusie object
#'


update_pi <- function( mvfsusie.obj, l, tpi, ...)
  UseMethod("update_pi")

#' @rdname update_pi
#'
#' @method update_pi mvfsusie
#'
#' @export update_pi.mvfsusie
#'
#' @export
#'
update_pi.mvfsusie <- function( mvfsusie.obj, l, tpi, ...)
{

  if( l > length(mvfsusie.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }

  mvfsusie.obj$est_pi[[l]] <- tpi
  out <- mvfsusie.obj
  class(out) <- "mvfsusie"
  return(out)
}






#'@title Update mvfsusie log Bayes factor
#'
#'@param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'@param l effect to update
#'@param lBF vector of length p, containning the updated log Bayes factors
#'@return mvfsusie object
#'@export

update_lBF  <- function    (mvfsusie.obj, l, lBF, ...)
  UseMethod("update_lBF")

#' @rdname update_lBF
#'
#' @method update_lBF mvfsusie
#'
#' @export update_lBF.mvfsusie
#'
#' @export
#'

update_lBF.mvfsusie <- function    (mvfsusie.obj,l, lBF, ...)
{
  if(l> mvfsusie.obj$L)
  {
    stop("Error: trying to update more effects than the number of specified effect")
  }

  mvfsusie.obj$lBF[[l]] <- lBF
  return(mvfsusie.obj)
}








#'@title Update mvfsusie local False Sign Rate
#'
#'@param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#'@param l effect to update
#'
#' @param tens_post a object generated with  \code{\link{get_post_tens}} with argument all set to TRUE
#'
#'@return mvfsusie object
#'@export

update_lfsr  <- function    (mvfsusie.obj,l,tens_post ,...)
  UseMethod("update_lfsr")

#' @rdname update_lfsr
#'
#' @method update_lfsr mvfsusie
#'
#' @export update_lfsr.mvfsusie
#'
#' @export
#'

update_lfsr.mvfsusie <- function(mvfsusie.obj,l,post_tens,...)
{
  mvfsusie.obj$lfsr_wc[[l]] <- post_tens$lfsr_tens
  return(mvfsusie.obj)
}




#' @title Compute posterior mean of the fitted effect
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param l , optional effect to update
#'
#' @return  A J by T matrix of posterior wavelet coefficient,
#' \item{if l missng}{return sum of effect posterior mean }
#' \item{if l not missng}{return effect specific posterior mean}
get_post_F <- function(mvfsusie.obj,l,...)
  UseMethod("get_post_F")

#' @rdname get_post_F
#'
#' @method get_post_F mvfsusie
#'
#' @export get_post_F.mvfsusie
#'
#' @export
#'

get_post_F.mvfsusie <- function(mvfsusie.obj,l,...)
{
  if(missing(l))
  {
    out <-  Reduce("+",lapply(1:mvfsusie.obj$L, FUN=function(l) mvfsusie.obj$alpha[[l]] * mvfsusie.obj$fitted_wc[[l]]))
  }else{
    out <-   mvfsusie.obj$alpha[[l]] * mvfsusie.obj$fitted_wc[[l]]
  }

  return(out)
}



#' @title Compute posterior second moment
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#' @param l , optional effect to update
#'
#' @return  A J by T matrix of posterior wavelet coefficient,
#' \item{if l  missng}{return sum of the  effect  posterior second moment }
#' \item{if l not missng}{return effect specific posterior second moment}

get_post_F2 <- function(mvfsusie.obj,l,...)
  UseMethod("get_post_F2")

#' @rdname get_post_F2
#'
#' @method get_post_F2 mvfsusie
#'
#' @export get_post_F2.mvfsusie
#'
#' @export
#'
get_post_F2.mvfsusie <- function(mvfsusie.obj, l,...)
{
  if(missing(l))
  {
    out <-  Reduce("+",lapply(1:mvfsusie.obj$L, FUN=function(l) mvfsusie.obj$alpha[[l]] *(mvfsusie.obj$sigma2+ mvfsusie.obj$fitted_wc2[[l]])))
  }else{
    out <-   mvfsusie.obj$alpha[[l]] *(mvfsusie.obj$sigma2+ mvfsusie.obj$fitted_wc2[[l]])
  }

  return(out)
}




#' @title Compute Epected sum of square
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param DW_tens tensor of  wavelet transformed  functional phenotype, size NxJxXi
#' @param X matrix of size N by p
#'
#'
#' @return estimated residual variance
#' @export
get_ER2 <- function(mvfsusie.obj,update_DW_tens,X, ... )
  UseMethod("get_ER2")


#' @rdname get_ER2
#'
#' @method get_ER2 mvfsusie
#'
#' @export get_ER2.mvfsusie
#'
#' @export

get_ER2.mvfsusie = function (  mvfsusie.obj,DW_tens, X) {
  postF <- get_post_F(mvfsusie.obj )# J by N matrix
  Xr_L =  (X%x% postF)
  postF2 <- get_post_F2(mvfsusie.obj ) # Posterior second moment.
  return(sum((DW_tens - X%x%postF )^2)  -sum(postF)^2 + sum(postF2))
}



#' @title Update residual variance
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param DW_tens tensor of  wavelet transformed  functional phenotype, size NxJxXi
#' @param X matrix of size N by p
#'
#'
#' @return estimated residual variance
#' @export
estimate_residual_variance <- function(mvfsusie,DW_tens,X, ... )
  UseMethod("estimate_residual_variance")


#' @rdname estimate_residual_variance
#'
#' @method estimate_residual_variance mvfsusie
#'
#' @export estimate_residual_variance.mvfsusie
#'
#' @export
estimate_residual_variance.mvfsusie <- function(mvfsusie.obj,DW_tens,X, ... )
{
  out <-  (1/(prod(dim(DW_tens))))*get_ER2 (mvfsusie.obj,DW_tens, X  )
  return(out)
}









#' @title Preparing output of main mvfsusie function
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, mvfsusie internally remaps the data into a grid of length 2^J
#'
#' @param X matrix of size N by p
#'
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'
#' @param filter.cs logical, if TRUE filter the credible set (removing low purity cs and cs with estimated prior equal to 0)
#'
#' @param lfsr_curve Maximum local false sign rate of the wavelet coefficients used to reconstruct lfsr_curves (see output)
#' @return mvfsusie object
#'
#' @export
#'
out_prep <- function(mvfsusie.obj,Y, X, indx_lst, filter.cs, lfsr_curve, ...)
  UseMethod("out_prep")

#' @rdname out_prep
#'
#' @method out_prep mvfsusie
#'
#' @export out_prep.mvfsusie
#'
#' @export
#'

out_prep.mvfsusie <- function(mvfsusie.obj,Y, X, indx_lst, filter.cs, lfsr_curve, ...)
{
  mvfsusie.obj <-  update_cal_pip(mvfsusie.obj)
  mvfsusie.obj <-  update_cal_cs(mvfsusie.obj)
  mvfsusie.obj <-  update_cal_fit_func(mvfsusie.obj, indx_lst)
  if(filter.cs)
  {
    mvfsusie.obj <- check_cs(mvfsusie.obj)
  }
  mvfsusie.obj <-  update_cal_indf(mvfsusie.obj, Y, X, indx_lst)
  mvfsusie.obj <-  update_cal_lfsr_func(mvfsusie.obj, lfsr_curve, indx_lst)

  return(mvfsusie.obj)
}




#'@title Update mvfsusie by computing PiP
#'
#'@param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'@return mvfsusie object
#'@export

update_cal_pip  <- function (mvfsusie.obj, ...)
  UseMethod("update_cal_pip")

#' @rdname update_cal_pip
#'
#' @method update_cal_pip mvfsusie
#'
#' @export update_cal_pip.mvfsusie
#'
#' @export
#'

update_cal_pip.mvfsusie <- function (mvfsusie.obj, ...)
{
  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  tpip <- list()
  for ( l in 1:mvfsusie.obj$L)
  {
    tpip[[l]] <- rep(1, lengths(mvfsusie.obj$alpha)[[l]])-mvfsusie.obj$alpha[[l]]
  }
  mvfsusie.obj$pip <- 1-  apply( do.call(rbind,tpip),2, prod)
  return(mvfsusie.obj)
}




#'@title Update mvfsusie by computing credible sets
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param cov_lev numeric between 0 and 1, corresponding to the expected level of coverage of the cs if not specified set to 0.95
#'
#' @return mvfsusie object
#'
#' @export

update_cal_cs  <- function(mvfsusie.obj, cov_lev=0.95, ...)
  UseMethod("update_cal_cs")

#' @rdname update_cal_cs
#'
#' @method update_cal_cs mvfsusie
#'
#' @export update_cal_cs.mvfsusie
#'
#' @export
#'

update_cal_cs.mvfsusie <- function(mvfsusie.obj, cov_lev=0.95)
{
  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  for ( l in 1:mvfsusie.obj$L)
  {
    temp        <- mvfsusie.obj$alpha[[l]]
    temp_cumsum <- cumsum( temp[order(temp, decreasing =TRUE)])
    max_indx_cs <- min(which( temp_cumsum >cov_lev ))
    mvfsusie.obj$cs[[l]]  <- order(temp, decreasing = TRUE)[1:max_indx_cs ]

  }

  return(mvfsusie.obj)
}


#' @title Update mvfsusie by computing posterior curves
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#'
#' @return mvfsusie object
#'
#' @export
update_cal_fit_func  <- function(mvfsusie.obj, indx_lst, ...)
  UseMethod("update_cal_fit_func")



#' @rdname update_cal_fit_func
#'
#' @method update_cal_fit_func mvfsusie
#'
#' @export update_cal_fit_func.mvfsusie
#'
#' @importFrom wavethresh wr
#'
#' @importFrom wavethresh wd
#'
#' @export
#'

update_cal_fit_func.mvfsusie <- function(mvfsusie.obj, indx_lst, ...)
{

  if(sum( is.na(unlist(mvfsusie.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  temp <- wd(rep(0, mvfsusie.obj$n_wac))

    for ( l in 1:mvfsusie.obj$L)
    {

     tens                          <-  mvfsusie.obj$alpha[[l]] %vxtens% mvfsusie.obj$fitted_wc[[l]]
     mvfsusie.obj$fitted_func[[l]] <- wr_tens(tens, temp, indx_lst)
    }




  return(mvfsusie.obj)
}






#' @title Update residual variance
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @param sigma2 estimate residual variance
#'
#' @return updated mvfsusie.obj




update_residual_variance  <- function(mvfsusie.obj,sigma2, ...)
  UseMethod("update_residual_variance")

#' @rdname update_residual_variance
#'
#' @method update_residual_variance mvfsusie
#'
#' @export update_residual_variance.mvfsusie
#'
#' @export
#'

update_residual_variance.mvfsusie <- function(mvfsusie.obj,sigma2)
{
  mvfsusie.obj$sigma2 <- sigma2
  return(mvfsusie.obj)
}








######## A FINIR ---------


#' @title Check purity credible sets
#'
#' @param mvfsusie.obj a mvfsusie object defined by \code{\link{init_mvfsusie_obj}} function
#'
#' @return a mvfsusie.obj without "dummy" credible sets
#'
#' @export
check_cs  <- function(mvfsusie.obj, ...)
  UseMethod("check_cs")



#' @rdname check_cs
#'
#' @method check_cs mvfsusie
#'
#' @export check_cs.mvfsusie
#'
#' @export
#'

check_cs.mvfsusie <- function(mvfsusie.obj, min.purity=0.5)
{
  dummy.cs<- c()


  if( class(mvfsusie.obj$G_prior)=="mixture_normal")
  {
    for (l in 1:mvfsusie.obj$L )
    {

      if (length(mvfsusie.obj$cs[[l]])==1)
      {

        if( mvfsusie.obj$est_pi[[l]][1]==1){# check if the estimated prior is exactly 0

          dummy.cs<-  c( dummy.cs,l)
        }

      }else{

        if( min(cor( X[,mvfsusie.obj$cs[[l]]])) <  min.purity){#check if the purity of cs l is lower that min.purity

          dummy.cs<-  c( dummy.cs,l)

        }else{
          if(mvfsusie.obj$est_pi[[l]][1]==1){
            dummy.cs<-  c( dummy.cs,l)
          }

        }
      }

    }
    if( length(dummy.cs)==0)
    {
      return(mvfsusie.obj)
    }else{
      if(length(dummy.cs)==mvfsusie.obj$L) #avoid returning empty results
      {
        dummy.cs <- dummy.cs[-length(dummy.cs)]
      }
      mvfsusie.obj <- discard_cs( mvfsusie.obj,cs=dummy.cs)
      return(mvfsusie.obj)
    }
  }


  if(class(mvfsusie.obj$G_prior)=="mixture_normal_per_scale")
  {
    for (l in 1:mvfsusie.obj$L )
    {

      if (length(mvfsusie.obj$cs[[l]])==1)
      {

        if(  mean(sapply(mvfsusie.obj$est_pi[[l]],"[[",1))==1){# check if the estimated prior is exactly 0

          dummy.cs<-  c( dummy.cs,l)
        }

      }else{

        if( min(cor( X[,mvfsusie.obj$cs[[l]]])) <  min.purity){#check if the purity of cs l is lower that min.purity

          dummy.cs<-  c( dummy.cs,l)

        }else{
          if( mean(sapply(mvfsusie.obj$est_pi[[l]],"[[",1))==1){
            dummy.cs<-  c( dummy.cs,l)
          }

        }
      }

    }
    if( length(dummy.cs)==0)
    {
      return(mvfsusie.obj)
    }else{
      if(length(dummy.cs)==mvfsusie.obj$L) #avoid returning empty results
      {
        dummy.cs <- dummy.cs[-length(dummy.cs)]
      }
      mvfsusie.obj <- discard_cs( mvfsusie.obj,cs=dummy.cs)
      return(mvfsusie.obj)
    }
  }

}
